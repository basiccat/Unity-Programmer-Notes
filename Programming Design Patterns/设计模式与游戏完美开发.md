

# 状态（State）
“让一个对象的行为随着内部状态的改变而变化，而该对象也像是换了类一样。”
状态的转换可以交由类对象本身，或者由State对象负责。

# 外观（Facade）
“为子系统定义一组统一的接口，这个高级的接口会让子系统更容易被使用。”
对外。

# 单例（Singleton）
太常见了，需要注意一些语法问题。容易滥用。

为什么想要单例？同时间只有一个对象，而且可以快速获取这个对象。

可以通过传参或静态引用来减少单例的使用。

```
private static AmbientAudioPlayer instance = null;

public static AmbientAudioPlayer GetInstance()
{
    if (instance == null)
    {
        instance = new AmbientAudioPlayer();
    }
    return instance;
}
```

# 中介者（Mediator）
“定义一个接口用来封装一群对象的互动行为。中介者通过移除对象间的引用，来减少耦合度，并且能改变他们之间的独立互动性。”
但容易产生接口过大的问题。

# 桥接（Bridge）
“将抽象和实现分离，使二者可以独立地变化。”
“抽象类”和“实现类”两个类群组间，关系呈现交叉组合汇编的情况。
“实现类”用来实现“抽象类”中定义的功能。

优点：
- 把抽象接口与其实现解耦。
- 抽象和实现可以独立扩展，不会影响到对方。
- 实现细节对客户透明，对用于隐藏了具体实现细节。

缺点： 
- 增加了系统的复杂度

我们再来看看桥接模式的使用场景，在以下情况下应当使用桥接模式：
- 如果一个系统需要在构件的抽象化角色和具体化角色之间添加更多的灵活性，避免在两个层次之间建立静态的联系。
- 设计要求实现化角色的任何改变不应当影响客户端，或者实现化角色的改变对客户端是完全透明的。
- 需要跨越多个平台的图形和窗口系统上。
- 一个类存在两个独立变化的维度，且两个维度都需要进行扩展。


# 策略（Strategy）
“定义一组算法，并封装每个算法，让他们可以彼此交换使用。”

# 模板方法（Template Method）
“在一个操作方法中定义算法的流程，其中某些步骤交由子类完成。模板方法模式让子类在不改变原有算法流程的情况下，还能够重新定义其中的步骤。”


# 工厂方法（Factory Method）
“定义一个可以产生对象的接口，但让子类决定要产生哪一个类的对象。工厂方法模式让类的实例化程序延迟到子类中实施。”

分为无参数和有参数。
无参数工厂，每一个产品Product都要创建一个Creator的子类。可以使用模板技术来改进。
有参数工厂方法通常用标识符来创建更多“产品”。

作为一种优化，可以使用lazy initialization。

用户得到的通常都是产品的抽象类引用，只能使用抽象类的接口操作具体对象，要不要向下转换看心情。

# 生成器（Builder）
“将一个复杂对象的构建流程与它的对象表现分离出来，让相同的构建流程可以产生不同的对象行为表现。”

导向器负责指挥生成器，一步步构建最终的“产品”。
导向器只使用生成器提供的接口，所以生成器的内部实现可以更改，进而影响最终产物。

在建造者模式中，指挥者是直接与客户端打交道的，指挥者将客户端创建产品的请求划分为对各个部件的建造请求，再将这些请求委派到具体建造者角色，具体建造者角色是完成具体产品的构建工作的，却不为客户所知道。

建造者模式主要用于“分步骤来构建一个复杂的对象”，其中“分步骤”是一个固定的组合过程，而复杂对象的各个部分是经常变化的（也就是说电脑的内部组件是经常变化的，这里指的的变化如硬盘的大小变了，CPU由单核变双核等）。

产品不需要抽象类，由于建造模式的创建出来的最终产品可能差异很大，所以不大可能提炼出一个抽象产品类。

由于建造者隐藏了具体产品的组装过程，所以要改变一个产品的内部表示，只需要再实现一个具体的建造者就可以了，从而能很好地应对产品组成组件的需求变化。

# 享元（Flyweight）
“使用共享的方式，让一大群小规模对象能更有效地运行。”
“共享”，“一大群小对象”。

# 组合（Composite）
“将对象以树状结构组合，用以表现部分-全体的层次关系。组合模式让客户端在操作各个对象或组合对象时是一致的。”

# 命令（Command）
“将请求封装成对象，让客户端的不同请求参数化，并配合队列，记录，复原等方法来执行请求的操作。”

# 责任链（Chain of Responsibility）
“让一群对象有机会来处理一项请求，以减少请求发送者与接收者之间的耦合度。将所有接收者对象串联起来，让请求沿着串接传递，直到有一个对象可以处理为止。”

# 观察者（Observer）
“在对象之间定义一个一对多的连接方法，当一个对象变换状态时，其它关联的对象都会自动收到通知。”
主题（Subject）改变后，改变的内容如何让观察者（Observer）得知？可以“推信息”和“拉信息”。

# 备忘录（Memento）
“在不违反封装的规则下，获取一个对象的内部状态并保留在外部，让该对象可以在日后恢复到原先保留时的状态。”
让有记录保存需要的类，自行产生需要保存的数据，外界不操心这些记录的产生和来源。类也自己从之前保存的数据中找回信息。

# 访问者（Visitor）
“定义一个能够在一个对象结构中对于所有元素执行的操作。访问者让你可以定义一个新的操作，而不必更改到被操作元素的类接口上。”
符合“开闭原则”，新增方法来增加功能，不修改现有程序代码。

但是如果继承层次很多，为了访问到尽可能多对象，访问者类为了应对不同子类型会变得很庞大，新增操作需要顾及子类是否需要重新实现。
另一方面，被访问者类需要提供足够的信息查询接口给访问者，破坏了封装性。

# 装饰模式（Decorator）
“动态地附加额外的责任给一个对象。装饰模式提供了一个灵活的选择，让子类可以用来扩展功能。”
新增的子类不一定要完全符合“类封装时的抽象定义”。
适用于已有装饰的目标，但装饰需求是后期出现的情形，最好不要滥用。

# 适配器模式（Adapter）
“将一个类的接口转换成客户端期待的类的接口，让原本接口不兼容的类能一起合作。”
亦可用于减少对第三方库的依赖。

复用已有类，将此类加入自己的框架中，但是接口不同，需要进行包装（Wrap）。
类适配器使用多重继承，公有继承接口，私有继承接口实现（已有类）。
对象适配器使用对象组合的方法，在接口实现中调用已有对象的操作。相比类适配器更灵活，可以同时适配被适配类的子类。

# 代理模式（Proxy）
“提供一个代理者位置给一个对象，好让代理者可以控制存取这个对象。”
代理模式可以选择新功能是否执行，装饰模式除了原有功能外也要执行新功能。

# 迭代器（Iterator）
“在不知道集合内部细节的情况下，提供一个按序方法存取一个对象集合体的每一个单元。”

# 原型（Prototype）
“使用原型对象来产生指定类的对象，所以产生对象时，使用复制原型对象完成。”

照我的理解，不再需要知道自己引用对象的创建流程，而是直接从自己引用的对象克隆一个新的对象出来。可是从结果来看并没有什么太大的区别，可能真的在取得新对象上更加方便一些。
可能有一种情况，在类继承的前提下，访问抽象父类接口的克隆方法有可能制造出子类的对象，而外部用户不需要知道这个子类对象的具体类型，反正都有着统一的接口。

最好的实践方式是使用原型管理器，最大的难题是深拷贝。

- 原型模式向客户隐藏了创建新实例的复杂性
- 原型模式允许动态增加或较少产品类。
- 原型模式简化了实例的创建结构，工厂方法模式需要有一个与产品类等级结构相同的等级结构，而原型模式不需要这样。
- 产品类不需要事先确定产品的等级结构，因为原型模式适用于任何的等级结构

原型模式的缺点：
- 每个类必须配备一个克隆方法

配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。

# 解释器（Interpreter）
“定义一个程序设计语言所需要的语句，并提供解释来解析该语言。”

# 抽象工厂（Abstract Factory）
“提供一个能够建立整个类群组或有关联的对象，而不指明它们的具体类。”、
抽象工厂接口定义了产生不同类对象的方法，继承的工厂子类实现产生不同产品的类。

抽象工厂，声明创建抽象产品对象的接口，是工厂方法的集合。

客户只需要与抽象类定义的**接口**交互，而不使用特定具体类的接口。
并不是客户只知道抽象类和抽象类的接口，客户也知道抽象类的子类，只是只使用抽象类(工厂以及产品)定义的接口。
客户只使用抽象工厂定义的接口，意思是客户在自己的代码中，只涉及抽象工厂提供的接口。
客户要选择具体使用什么样的工厂。

抽象工厂允许客户使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么。这样客户就可以从具体产品中被解耦。

优缺点

抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展，这真是抽象工厂模式的优点所在，然后抽象模式同时也存在不足的地方。下面就具体看下抽象工厂的缺点（缺点其实在前面的介绍中以已经涉及了）：

抽象工厂模式很难支持新种类产品的变化。这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。

知道了抽象工厂的优缺点之后，也就能很好地把握什么情况下考虑使用抽象工厂模式了，下面就具体看看使用抽象工厂模式的系统应该符合那几个前提：
- 一个系统不要求依赖产品类实例如何被创建、组合和表达的表达，这点也是所有工厂模式应用的前提。
- 这个系统有多个系列产品，而系统中只消费其中某一系列产品
- 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。
