
- [值和引用](#值和引用)
  - [值类型与引用类型](#值类型与引用类型)
  - [理解参数按值传递？以及按引用传递？](#理解参数按值传递以及按引用传递)
  - [delegate是引用类型还是值类型？enum、int[]和string呢？](#delegate是引用类型还是值类型enumint和string呢)
  - [堆和栈的区别？](#堆和栈的区别)
  - [“结构”对象可能分配在堆上吗？什么情况下会发生，有什么需要注意的吗？](#结构对象可能分配在堆上吗什么情况下会发生有什么需要注意的吗)
  - [out和ref的区别与相同点？](#out和ref的区别与相同点)
  - [有几种方法可以判定值类型和引用类型？](#有几种方法可以判定值类型和引用类型)
- [装箱与拆箱](#装箱与拆箱)
  - [什么是拆箱和装箱？](#什么是拆箱和装箱)
  - [装箱的过程？](#装箱的过程)
  - [拆箱的过程？](#拆箱的过程)
  - [装箱和拆箱有什么性能影响？](#装箱和拆箱有什么性能影响)
  - [如何避免隐式装箱？](#如何避免隐式装箱)
- [string与字符串操作](#string与字符串操作)
  - [字符串是引用类型类型还是值类型？](#字符串是引用类型类型还是值类型)
  - [在字符串连加处理中，最好采用什么方式，理由是什么？](#在字符串连加处理中最好采用什么方式理由是什么)
  - [简述StringBuilder和String的区别？](#简述stringbuilder和string的区别)
  - [字符串对象的不可变性](#字符串对象的不可变性)
  - [字符串内插](#字符串内插)
  - [Null 字符串和空字符串](#null-字符串和空字符串)
  - [正则表达式](#正则表达式)
- [类与接口](#类与接口)
  - [访问修饰符](#访问修饰符)
  - [解释virtual、sealed、override和abstract的区别](#解释virtualsealedoverride和abstract的区别)
  - [interface和abstract class有什么区别？](#interface和abstract-class有什么区别)
  - [结构和类的区别？](#结构和类的区别)
  - [静态构造函数](#静态构造函数)
  - [在类的构造函数前加上static会报什么错?为什么?](#在类的构造函数前加上static会报什么错为什么)
  - [能用foreach遍历访问的对象需要实现接口或声明_方法的类型](#能用foreach遍历访问的对象需要实现接口或声明_方法的类型)
  - [List<T>与IList<T>的区别是什么？](#listt与ilistt的区别是什么)
  - [using关键字的使用场景](#using关键字的使用场景)
  - [new关键字的使用场景](#new关键字的使用场景)
  - [return执行顺序](#return执行顺序)
  - [重载与覆盖的区别？](#重载与覆盖的区别)
  - [举例子非常重要](#举例子非常重要)
- [常量、字段、属性、特性与委托](#常量字段属性特性与委托)
  - [const和readonly有什么区别？](#const和readonly有什么区别)
  - [字段与属性有什么异同？](#字段与属性有什么异同)
  - [特性是什么？如何使用？](#特性是什么如何使用)
  - [static关键字的应用](#static关键字的应用)
  - [class中定义的静态字段是存储在内存中的哪个地方？为什么会说她不会被GC回收？](#class中定义的静态字段是存储在内存中的哪个地方为什么会说她不会被gc回收)
  - [简述static和const关键字的作用](#简述static和const关键字的作用)
  - [静态成员和非静态成员的区别？](#静态成员和非静态成员的区别)
  - [C#中的委托是什么？事件是不是一种委托？](#c中的委托是什么事件是不是一种委托)
  - [区别委托和事件event](#区别委托和事件event)
  - [Action 委托](#action-委托)
  - [系统委托有Action(注册的方法无返回值)，Func（注册的方法有返回值），Predicate(返回值为bool类型)](#系统委托有action注册的方法无返回值func注册的方法有返回值predicate返回值为bool类型)
  - [switch(expression)](#switchexpression)
  - [匿名和lamda表达式](#匿名和lamda表达式)
- [GC与内存管理](#gc与内存管理)
  - [GC（Garbage Collection）](#gcgarbage-collection)
  - [GC进行垃圾回收时的主要流程是？](#gc进行垃圾回收时的主要流程是)
  - [GC在哪些情况下回进行回收工作？](#gc在哪些情况下回进行回收工作)
  - [using() 语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？](#using-语法是如何确保对象资源被释放的如果内部出现异常依然会释放资源吗)
  - [解释一下C#里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？](#解释一下c里的析构函数为什么有些编程建议里不推荐使用析构函数呢)
  - [Finalize() 和 Dispose() 之间的区别？](#finalize-和-dispose-之间的区别)
  - [.NET中的托管堆中是否可能出现内存泄露的现象?](#net中的托管堆中是否可能出现内存泄露的现象)
  - [在托管堆上创建新对象有哪几种常见方式？](#在托管堆上创建新对象有哪几种常见方式)
- [多线程编程与线程同步](#多线程编程与线程同步)
  - [描述线程与进程的区别？](#描述线程与进程的区别)
  - [进程状态的转换](#进程状态的转换)
  - [线程和进程之间的通讯方式](#线程和进程之间的通讯方式)
    - [进程间的通信方式](#进程间的通信方式)
    - [线程间的通信方式](#线程间的通信方式)
  - [线程同步](#线程同步)
  - [lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？](#lock为什么要锁定一个参数可不可锁定一个值类型这个参数有什么要求)
  - [Mutex和lock有何不同？一般用哪一个作为锁使用更好？](#mutex和lock有何不同一般用哪一个作为锁使用更好)
  - [多线程和异步有什么关系和区别？](#多线程和异步有什么关系和区别)
  - [线程池的优点有哪些？又有哪些不足？](#线程池的优点有哪些又有哪些不足)
  - [并发和并行](#并发和并行)
- [其它](#其它)
  - [执行模型 CLR（Common Language Runtime）](#执行模型-clrcommon-language-runtime)
  - [JIT 编译器和 IL](#jit-编译器和-il)
  - [AOT 编译器](#aot-编译器)
  - [文件I/O](#文件io)
  - [序列化与反序列化](#序列化与反序列化)
    - [Unity3D中序列化注意事项 Pure C# Class](#unity3d中序列化注意事项-pure-c-class)
  - [Hash表的原理是什么, 如何实现?](#hash表的原理是什么-如何实现)
  - [拓展方法](#拓展方法)
  - [反射Reflection](#反射reflection)
  - [反射的实现原理？](#反射的实现原理)
  - [请简述ArrayList和List的主要区别？](#请简述arraylist和list的主要区别)
  - [浅克隆与深克隆（浅拷贝与深拷贝）](#浅克隆与深克隆浅拷贝与深拷贝)
  - [C#中四种访问修饰符是哪些？各有什么区别？](#c中四种访问修饰符是哪些各有什么区别)


# 值和引用

## 值类型与引用类型

值类型包括简单类型、结构体类型和枚举类型，引用类型包括自定义类、数组、接口、委托等。

>值类型：包含了所有简单类型（整数、浮点、bool、char），struct、enum、int、float、char、bool、decimal
>
>继承自System.ValueTyoe
> 
>引用类型包含了【string】，object，class，interface，delegate，array
>
>继承自System.Object

内存区域上的区别

>值类型：数据存储在栈上，超出作用域就自动清理
>
>引用类型：数据存储在托管堆上，引用地址在线程栈上，地址指向数据存放的堆上
>
>托管堆会由GC来自动释放 ，线程栈数据在作用域结束后会被清理。

使用引用类型的时候，一般是对指针进行的操作而非引用类型对象本身。但是值类型则操作其本身。

继承：值类型不可能派生出新的类型，所有的值类型均隐式派生自 System.ValueType。但与引用类型相同的是，结构也可以实现接口。

null：与引用类型不同，值类型不可能包含 null 值。然而，可空类型功能允许将 null 赋给值类型。

每种值类型均有一个隐式的默认构造函数来初始化该类型的默认值，值类型初始会默认为0，引用类型默认为null。

## 理解参数按值传递？以及按引用传递？

拷贝策略：值类型是拷贝数据，引用类型是拷贝引用地址

按值传递：对于值类型传递的它的值拷贝副本，而引用类型传递的是引用变量的内存地址，他们还是指向的同一个对象。
按引用传递：通过关键字out和ref传递参数的内存地址，值类型和引用类型的效果是相同的。

值传递时，系统首先为被调用方法的形参分配内存空间，并将实参的值按位置一一对应地复制给形参，此后，被调用方法中形参值得任何改变都不会影响到相应的实参；

引用传递时，系统不是将实参本身的值复制后传递给形参，而是将其引用值（即地址值）传递给形参，因此，形参所引用的该地址上的变量与传递的实参相同，方法体内相应形参值的任何改变都将影响到作为引用传递的实参。

简而言之，按值传递不是值参数是值类型，而是指形参变量会复制实参变量，也就是会在栈上多创建一个相同的变量。而按引用传递则不会。可以通过 ref 和 out 来决定参数是否按照引用传递。

## delegate是引用类型还是值类型？enum、int[]和string呢？

enum枚举是值类型，其他都是引用类型。

## 堆和栈的区别？

- 线程堆栈：简称栈 Stack
- 托管堆： 简称堆 Heap

值类型【大多】分配在栈上，引用类型都分配在堆上。

栈由系统自动分配和维护。存放在栈中时要管存储顺序，保持着先进后出的原则，他是一片连续的内存域。栈上的变量在其作用域完成后就被释放，效率较高，但空间有限。

堆是无序的，他是一片不连续的内存域，有用户自己来控制和释放，如果用户自己不释放的话，当内存达到一定的特定值时，通过垃圾回收器(GC)来回收。

> 栈内存无需我们管理，也不受GC管理。当栈顶元素使用完毕，立马释放。
> 
> 而堆则需要GC清理。堆受CLR的GC控制。

> 栈是基于线程的，每个线程都有自己的线程栈，初始大小为1M。
> 
> 堆是基于进程的，一个进程分配一个堆，堆的大小由GC根据运行情况动态控制；

>通常来讲，变量的值分配与其声明该变量的位置有关。局部变量的值总是在栈上的。实例变量的值则和实例本身一起储存在实例储存的地方。引用类型实例和静态总是储存在堆上的。
数组的元素、引用类型中的值类型字段等，引用类型的确总是分配在托管堆上，但是值类型并非总是分配在线程栈上有可能分配在堆上。

如果结构体中定义引用类型，对象在内存中是如何存储的？例如下面结构体中的class类 User对象是存储在栈上，还是堆上？
```
public struct MyStruct 
{ 
    public int Index; 
    public User User; 
}
```
MyStruct存储在栈中，其字段User的实例存储在堆中，MyStruct.User字段存储指向User对象的内存地址。

## “结构”对象可能分配在堆上吗？什么情况下会发生，有什么需要注意的吗？

结构是值类型，有两种情况会分配在对上面：
>结构作为class的一个字段或属性，会随class一起分配在堆上面；
>
>装箱后会在堆中存储，尽量避免值类型的装箱，值类型的拆箱和装箱都有性能损失。

## out和ref的区别与相同点？

out 和 ref都指示编译器传递参数地址，在行为上是相同的；

- ref指定的参数在函数调用时必须先初始化，而out不用
- out指定的参数在进入函数时会清空自己，因此必须在函数内部进行初始化赋值操作，而ref不用

总结：ref可以把值传到方法里，也可以把值传到方法外；out只可以把值传到方法外

out 和 ref不可以重载，就是不能定义Method(ref int a)和Method(out int a)这样的重载，从编译角度看，二者的实质是相同的，只是使用时有区别；

注意：string作为特殊的引用类型，其操作是与值类型看齐的，若要将方法内对形参赋值后的结果传递出来，需要加上ref或out关键字。

## 有几种方法可以判定值类型和引用类型？

简单来说，继承自System.ValueType的是值类型，反之是引用类型。


# 装箱与拆箱

## 什么是拆箱和装箱？
- 装箱：把值类型转换成引用类型
- 拆箱：把引用类型（被装箱的对象）转换成值类型

## 装箱的过程？

对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。

> 第一步：新分配托管堆内存(大小为值类型实例大小加上一个方法表指针。
> 
> 第二步：将值类型的实例字段拷贝到新分配的内存中。
> 
> 第三步：返回托管堆中新分配对象的地址。这个地址就是一个指向对象的引用了。

## 拆箱的过程？

检查对象实例，确保它是给定值类型的一个装箱值。将该值从实例复制到值类型变量中。

>检查实例对象（object o）是否有效，如是否为null，其装箱的类型与拆箱的类型是否一致，如检测不合法，抛出异常；
>
>指针返回，就是获取装箱对象（object o）中值类型字段值的地址；
>
>字段拷贝，把装箱对象（object o）中值类型字段值拷贝到栈上，意思就是创建一个新的值类型变量来存储拆箱后的值；

***在装箱时是不需要显式的类型转换的，不过拆箱需要显式的类型转换。***
 
string是特殊的引用类型，如果传入参数是string，在方法里修改，原string数值不变。

原因是string的不变性，系统内部做了特殊处理。

## 装箱和拆箱有什么性能影响？
如果值类型必须被频繁装箱，那么在这些情况下最好避免使用值类型（例如在诸如 System.Collections.ArrayList 的非泛型集合类中）。装箱和取消装箱过程需要进行大量的计算。对值类型进行装箱时，必须创建一个全新的对象。 这可能比简单的引用赋值用时最多长 20 倍。取消装箱的过程所需时间可达赋值操作的四倍。

## 如何避免隐式装箱？
解决办法就是第一是重载，第二是泛型。
可通过使用泛型集合（例如 System.Collections.Generic.List<T>）来避免装箱值类型。 

# string与字符串操作

## 字符串是引用类型类型还是值类型？
引用类型。

## 在字符串连加处理中，最好采用什么方式，理由是什么？
少量字符串连接，使用String.Concat，大量字符串使用StringBuilder，因为StringBuilder的性能更好，如果string的话会创建大量字符串对象。

StringBuilder 类创建字符串缓冲区，用于在程序执行多个字符串操控时提升性能。 使用 StringBuilder 字符串，还可以重新分配各个字符，而内置字符串数据类型则不支持这样做。


## 简述StringBuilder和String的区别？
String是字符串常量。

StringBuffer是字符串变量 ，线程安全。

StringBuilder是字符串变量，线程不安全。

String类型是个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象，如果在一个循环里面，不断的改变一个对象，就要不断的生成新的对象，所以效率很低，建议在不断更改String对象的地方不要使用String类型。

StringBuilder对象在做字符串连接操作时是在原来的字符串上进行修改，改善了性能。这一点我们平时使用中也许都知道，连接操作频繁的时候，使用StringBuilder对象。

## 字符串对象的不可变性
字符串对象是“不可变的”：它们在创建后无法更改。 看起来是在修改字符串的所有 String 方法和 C# 运算符实际上都是在新的字符串对象中返回结果。

## 字符串内插
在 C# 6.0 及更高版本中提供，内插字符串由 $ 特殊字符标识，并在大括号中包含内插表达式。使用字符串内插来改善代码的可读性和可维护性。 字符串内插可实现与 String.Format 方法相同的结果，但提高了易用性和内联清晰度。

## Null 字符串和空字符串
空字符串是包含零个字符的 System.String 对象实例。 空字符串常用在各种编程方案中，表示空文本字段。 可以对空字符串调用方法，因为它们是有效的 System.String 对象。

相比较而言，null 字符串并不指 System.String 对象实例，只要尝试对 null 字符串调用方法，都会引发 NullReferenceException。 但是，可以在串联和与其他字符串的比较操作中使用 null 字符串。 

## 正则表达式
正则表达式判断字符串更加简洁，但是需要懂一些语法，最主要的类是Regex

# 类与接口

## 访问修饰符

（1）public 公有访问，不受任何限制。

（2）private 私有访问，只限于本类成员访问。

（3）protected 保护访问，只限于本类和子类访问。

（4）internal 内部访问，只限于当前程序集内访问。

## 解释virtual、sealed、override和abstract的区别
virtual申明虚方法的关键字，说明该方法可以被重写
sealed声明类就不能继承，声明方法就是不能被重写
override重写基类的方法
abstract申明抽象类和抽象方法的关键字，抽象方法不提供实现，由子类实现，抽象类不可实例化。

## interface和abstract class有什么区别？

1、继承：接口可继承接口，并可多继承接口；抽象类只能被单个类继承。

2、表达的概念：接口用于规范，更强调契约，抽象类用于共性，强调父子。抽象类是一类事物的高度聚合，那么对于继承抽象类的子类来说，对于抽象类来说，属于"Is A"的关系；而接口是定义行为规范，强调“Can Do”的关系，因此对于实现接口的子类来说，相对于接口来说，是"行为需要按照接口来完成"。

3、方法实现：对抽象类中的方法，即可以给出实现部分，也可以不给出；而接口的方法（抽象规则）都不能给出实现部分，接口中方法不能加修饰符。

4、子类重写：继承类对于两者所涉及方法的实现是不同的。继承类对于抽象类所定义的抽象方法，可以不用重写，也就是说，可以延用抽象类的方法；而对于接口类所定义的方法或者属性来说，在继承类中必须重写，给出相应的方法和属性实现。

5、新增方法的影响：在抽象类中，新增一个方法的话，继承类中可以不用作任何处理；而对于接口来说，则需要修改继承类，提供新定义的方法。

6、接口可以作用于值类型（枚举可以实现接口）和引用类型，可以通过as运算符强转，获取某对象的接口的引用；抽象类只能作用于引用类型。

7、接口不能包含字段和已实现的方法，接口只包含方法、属性、索引器、事件的签名；抽象类可以定义字段、属性、包含有实现的方法。

8、接口中的所有成员默认为public，不能有private修饰符；抽象类中的虚方法或抽象方法必须用public修饰。

## 结构和类的区别？

- 结构体是值类型，类是引用类型。
- 结构不支持无参构造函数，不支持析构函数，并且不能有protected修饰；
- 结构常用于数据存储，类class多用于行为；
- 结构不能从另外一个结构或者类继承，本身也不能被继承；没有默认的构造函数，但是可以添加构造函数；可以不使用new 初始化

- class需要用new关键字实例化对象，struct可以不适用new关键字；
- class可以为抽象类，struct不支持抽象；
- Class属于引用类型，是分配在内存的堆上的；Struct属于值类型，是分配在内存的栈上的；

## 静态构造函数

最先被执行的构造函数，且在一个类里只允许有一个无参的静态构造函数

执行顺序：静态变量>静态构造函数>实例变量>实例构造函数

## 在类的构造函数前加上static会报什么错?为什么?
构造函数格式为 public+类名如果加上static会报错（静态构造函数不能有访问修饰符）

原因：静态构造函数不允许访问修饰符，也不接受任何参数； 

无论创建多少类型的对象，静态构造函数只执行一次； 

运行库创建类实例或者首次访问静态成员之前，运行库调用静态构造函数； 

静态构造函数执行先于任何实例级别的构造函数；

显然也就无法使用this和base来调用构造函数。
 
## 能用foreach遍历访问的对象需要实现接口或声明_方法的类型

IEnumerable；GetEnumerator

## List<T>与IList<T>的区别是什么？

首先IList 泛型接口是 ICollection 泛型接口的子代，并且是所有泛型列表的基接口。
它仅仅是所有泛型类型的接口，并没有太多方法可以方便实用，如果仅仅是作为集合数据的承载体，确实，IList<T>可以胜任。

不过，更多的时候，要对集合数据进行处理，从中筛选数据或者排序。这个时候IList<T>就爱莫能助了。

## using关键字的使用场景

（1）作为指令：用于导入其他命名空间中定义的类型或为命名空间创建别名

（2）作为语句：用于定义一个范围，在此范围的末尾将释放对象

## new关键字的使用场景

（1）new 约束指定泛型类声明中的类型实参必须有公共的无参数构造函数。 若要使用 new 约束，则该类型不能为抽象类型。

（2）在用作声明修饰符时，new 关键字可以显式隐藏从基类继承的成员。 

（3）new 运算符创建类型的新实例。

## return执行顺序

try{} 里有一个return语句，那么finally{} 里的code在return前执行。


## 重载与覆盖的区别？
重载：当类包含两个名称相同但签名不同(方法名相同,参数列表不相同)的方法时发生方法重载。用方法重载来提供在语义上完成相同而功能不同的方法。

覆写：在类的继承中使用，通过覆写子类方法可以改变父类虚方法的实现。

主要区别：

1、方法的覆盖是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系。 
2、覆盖只能由一个方法，或只能由一对方法产生关系；方法的重载是多个方法之间的关系。 
3、覆盖要求参数列表相同；重载要求参数列表不同。 
4、覆盖关系中，调用那个方法体，是根据对象的类型来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。

##  举例子非常重要

基类抽象人物工厂（接口）,子类具体玩家工厂，子类怪物工厂，子类npc工厂，抽象产品（接口）具体魔法师，弓箭手产品~

资源管理工厂，UI资源管理工厂，音频资源管理工厂，资源管理，UI资源管理，音频资源

# 常量、字段、属性、特性与委托

## const和readonly有什么区别？
const关键字用来声明编译时常量，readonly用来声明运行时常量。都可以标识一个常量，主要有以下区别： 
1、初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值，也可以在构造方法里赋值。 
2、修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段 。 
3、const是编译时常量，在编译时确定该值，且值在编译时被内联到代码中；readonly是运行时常量，在运行时确定该值。
4、const默认是静态的；而readonly如果设置成静态需要显示声明 。 
5、支持的类型时不同，const只能修饰基元类型或值为null的其他引用类型；readonly可以是任何类型。

``` 
   public class Program
    {
        public readonly int PORT;
        static void Main(string[] args)
        {
            B a = new B();
            Console.WriteLine(a.PORT);
            Console.WriteLine(B.PORT2);
            Console.WriteLine(a.PORT3.ccc);
            Console.ReadLine();
        }
    }

    class B
    {
        //readonly即可以在声明处赋值，也可以在构造方法里赋值
        public readonly int PORT;
        //const必须在声明的同时赋值
        public const int PORT2 = 10;

        //错误public const A PORT3 =  new A()    const只能修饰基元类型或值为null的其他引用类型

        //readonly可以是任何类型
        public readonly A PORT3 = new A();
        public B()
        {

            PORT = 11;
        }
    }
    class A
    {
        public string ccc = "aaaa";
    }    
```

## 字段与属性有什么异同？
- 属性提供了更为强大的，灵活的功能来操作字段；
- 出于面向对象的封装性，字段一般不设计为Public；
- 属性允许在set和get中编写代码；
- 属性允许控制set和get的可访问性，从而提供只读或者可读写的功能 （逻辑上只写是没有意义的）；
- 属性可以使用override 和 new

## 特性是什么？如何使用？
特性与属性是完全不相同的两个概念，只是在名称上比较相近。Attribute特性就是关联了一个目标对象的一段配置信息，本质上是一个类，其为目标元素提供关联附加信息，这段附加信息存储在dll内的元数据，它本身没什么意义。运行期以反射的方式来获取附加信息。

系统特性：Obsolete特性检查方法是否过时，Conditional特性实现条件编译，比如测试方法但是需要宏定义；

Unity中的特性：DllImport特性应用于方法，Serializable特性应用于类型，自定义特性和拓展编辑器。

## static关键字的应用
对类有意义的字段和方法使用static关键字修饰，称为静态成员，通过类名加访问操作符“.”进行访问; 对类的实例有意义的字段和方法不加static关键字，称为非静态成员或实例成员。

注: 静态字段在内存中只有一个拷贝，非静态字段则是在每个实例对象中拥有一个拷贝。而方法无论是否为静态，在内存中只会有一份拷贝，区别只是通过类名来访问还是通过实例名来访问。

## class中定义的静态字段是存储在内存中的哪个地方？为什么会说她不会被GC回收？
随类型对象存储在内存的加载堆上，因为加载堆不受GC管理，其生命周期随AppDomain，不会被GC回收。

## 简述static和const关键字的作用
static 关键字至少有下列几个作用：
（1）函数体内static 变量的作用范围为该函数体，不同于auto 变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
（2）在模块内的static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
（3）在模块内的static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
（4）在类中的static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
（5）在类中的static 成员函数属于整个类所拥有，这个函数不接收this 指针，因而只能访问类的static 成员变量。

const 关键字至少有下列几个作用：
（1）欲阻止一个变量被改变，可以使用const 关键字。在定义该const 变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
（3）在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
（4）对于类的成员函数，若指定其为const 类型，则表明其是一个常函数，不能修改类的成员变量；
（5）对于类的成员函数，有时候必须指定其返回值为const 类型，以使得其返回值不为“左值”。

## 静态成员和非静态成员的区别？
静态变量使用 static 修饰符进行声明，静态成员在加类的时候就被加载（上一篇中提到过，静态字段是随类型对象存放在Load Heap上的），通过类进行访问。
不带有static 修饰符声明的变量称做非静态变量，在对象被实例化时创建，通过对象进行访问 。
一个类的所有实例的同一静态变量都是同一个值，同一个类的不同实例的同一非静态变量可以是不同的值 。
静态函数的实现里不能使用非静态成员，如非静态变量、非静态函数等。

## C#中的委托是什么？事件是不是一种委托？
简单来说，委托类似于 C或 C++中的函数指针，允许将方法作为参数进行传递。

C#中的委托都继承自System.Delegate类型；

委托类型的声明与方法签名类似，有返回值和参数；

委托是一种可以封装命名（或匿名）方法的引用类型，把方法当做指针传递，但委托是面向对象、类型安全的；
事件可以理解为一种特殊的委托，事件内部是基于委托来实现的。

## 区别委托和事件event

侦听事件是可选的
>在确定要使用的语言功能时，最重要的考虑因素为是否必须具有附加的订阅服务器。 如果代码必须调用订阅服务器提供的代码，则在需要实现回调时，应使用基于委托的设计。 如果你的代码在不调用任何订阅服务器的情况下可完成其所有工作，则应使用基于事件的设计。

返回值需要委托
>另一个注意事项是委托方法所需的方法原型。 如你所见，用于事件的委托均具有无效的返回类型。 你还看到，存在创建事件处理程序的惯用语，该事件处理程序通过修改事件参数对象的属性将信息传回到事件源。 虽然这些惯用语可发挥作用，但它们不像从方法返回值那样自然。

>请注意，这两种试探法可能经常同时存在：如果委托方法返回值，则可能会以某种方式影响算法。

事件具有专用调用（invoke）
>包含事件的类以外的类只能添加和删除事件侦听器；只有包含事件的类才能调用事件。 事件通常是公共类成员。 相比之下，委托通常作为参数传递，并存储为私有类成员（如果它们全部存储）。

事件侦听器通常具有较长的生存期
>事件侦听器通常具有较长的生存期的这一理由不太充分。 但是，你可能会发现，当事件源将在很长一段时间内引发事件时，基于事件的设计会更加自然。 可以在许多系统上看到基于事件的 UX 控件设计示例。 订阅事件后，事件源可能会在程序的整个生存期内引发事件。 （当不再需要事件时，可以取消订阅事件。）
将其与许多基于委托的设计（其中委托用作方法的参数，且在返回该方法后不再使用此委托）进行比较。

>委托可以作为方法的参数，事件不可以；委托可以声明一个局部变量，事件不可以；事件其实是委托的一个特殊化的实例。

## Action 委托
封装一个方法，该方法只有一个参数并且不返回值。

public delegate void Action();

## 系统委托有Action(注册的方法无返回值)，Func（注册的方法有返回值），Predicate(返回值为bool类型)

## switch(expression)
其中expression支持任何数据类型，包括null。

## 匿名和lamda表达式
匿名将委托的实例化和委托方法合并；lamda表达式是对委托方法的进一步简化。


# GC与内存管理

[C#面试题(二)(包含答案) ------ GC/反射泛型](https://qianxi.blog.csdn.net/article/details/81033250)

## GC（Garbage Collection）
当程序需要更多的堆空间时，GC需要进行垃圾清理工作，暂停所有线程，找出所有无被引用的对象，进行清理，并通知栈中的指针重新指向地址排序后的对象。

GC只能处理托管内存资源的释放，对于非托管资源则不能使用GC进行回收，必须由程序员手动回收，例如FileStream或SqlConnection需要调用Dispose进行资源的回收。

比较常见的算法有Reference Counting，Mark Sweep，Copy Collection等等

## GC进行垃圾回收时的主要流程是？
① 标记：先假设所有对象都是垃圾，根据应用程序根Root遍历堆上的每一个引用对象，生成可达对象图，对于还在使用的对象（可达对象）进行标记（其实就是在对象同步索引块中开启一个标示位）。

② 清除：针对所有不可达对象进行清除操作，针对普通对象直接回收内存，而对于实现了终结器的对象（实现了析构函数的对象）需要单独回收处理。清除之后，内存就会变得不连续了，就是步骤3的工作了。

③ 压缩：把剩下的对象转移到一个连续的内存，因为这些对象地址变了，还需要把那些Root跟指针的地址修改为移动后的新地址。

## GC在哪些情况下回进行回收工作？
内存不足溢出时（0代对象充满时）；

Windwos报告内存不足时，CLR会强制执行垃圾回收；

CLR卸载AppDomian，GC回收所有；

调用GC.Collect；

其他情况，如主机拒绝分配内存，物理内存不足，超出短期存活代的存段门限

## using() 语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？
using() 只是一种语法形式，其本质还是try…finally的结构，可以保证Dispose始终会被执行。

## 解释一下C#里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？
C#里的析构函数其实就是终结器Finalize，因为长得像C++里的析构函数而已。

有些编程建议里不推荐使用析构函数要原因在于：第一是Finalize本身性能并不好；其次很多人搞不清楚Finalize的原理，可能会滥用，导致内存泄露，因此就干脆别用了

## Finalize() 和 Dispose() 之间的区别？
Finalize() 和 Dispose()都是.NET中提供释放非托管资源的方式，他们的主要区别在于执行者和执行时间不同：

- finalize由垃圾回收器调用；dispose由对象调用。
- finalize无需担心因为没有调用finalize而使非托管资源得不到释放，而dispose必须手动调用。
- finalize不能保证立即释放非托管资源，Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间；而dispose一调用便释放非托管资源。
- 只有class类型才能重写finalize，而结构不能；类和结构都能实现IDispose。
- 另外一个重点区别就是终结器会导致对象复活一次，也就说会被GC回收两次才最终完成回收工作，这也是有些人不建议开发人员使用终结器的主要原因。

## .NET中的托管堆中是否可能出现内存泄露的现象?
是的，可能会。比如：

不正确的使用静态字段，导致大量数据无法被GC释放；
没有正确执行Dispose()，非托管资源没有得到释放；
不正确的使用终结器Finalize()，导致无法正常释放资源；
其他不正确的引用，导致大量托管对象无法被GC释放；

## 在托管堆上创建新对象有哪几种常见方式？
new一个对象；

字符串赋值，如string s1=”abc”；

值类型装箱；

# 多线程编程与线程同步

## 描述线程与进程的区别？

进程：进程是对运行时程序的一个封装，是系统进行资源调度和分配的基本单位（在操作系统层面的并发）。

线程：线程是进程的子任务，是cpu调度和分派的基本单位（在进程层面的并发）。

简单来说就是，进程存在的意义是为了在cpu进行并发操作时，保护上下文，保护进程数据间不相互影响而设计出来的概念。有了进程我们就可以在单个cpu进行多进程分片，也可以多个cpu并发处理进程。而线程，就是在一个进程内其实也有多个逻辑，当一个逻辑需要io的时候，会白占cpu。而进程间切换的代价也比较大，为了提高效率，在就设计出可线程的概念，当进程中其中一个线程需要IO的时候，另一个线程来占用cpu以此提高效率。

>1.一个线程只能属于一个进程，而一个进程可以有多个线程，线程依赖于进程而存在。
>
>2.一个进程在执行的过程中有独立的内存空间，而线程之间共享进程的内存（线程有自己的寄存器组）。
>
>3.进程是资源分配的最小单位，而线程是cpu调度的最小单位
>
>4.进程之间切换开销大，而线程切换只需要保存一些寄存器数据
>
>5.进程之间相互独立不会造成影响，而线程之间会造成死锁

## 进程状态的转换
创建，就绪，执行，终止，阻塞

## 线程和进程之间的通讯方式

实际上只有进程间需要通信,同一进程的线程共享地址空间,没有通信的必要，但要做好同步/互斥,保护共享的全局变量。

而进程间通信无论是信号，管道pipe还是共享内存都是由操作系统保证的，是系统调用.

### 进程间的通信方式
- 管道(pipe)：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
- 有名管道(namedpipe)：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
- 信号量(semophore)：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- 消息队列(messagequeue)：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 信号(sinal)：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- 共享内存(shared memory)：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
- 套接字(socket)：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。

### 线程间的通信方式
锁机制：包括互斥锁、条件变量、读写锁
>互斥锁提供了以排他方式防止数据结构被并发修改的方法。
>
>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
>
>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

信号机制(Signal)：类似进程间的信号处理

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

## 线程同步
（1）方法一：阻塞（调用Sleep()或Join()）

（2）方法二：加互斥锁lock

（3）方法三：信号和句柄（AutoResetEvent/ManualResetEvent，调用Set()和WaitOne()）

##  lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？
lock的锁对象要求为一个引用类型。她可以锁定值类型，但值类型会被装箱，每次装箱后的对象都不一样，会导致锁定无效。

对于lock锁，锁定的这个对象参数才是关键，这个参数的同步索引块指针会指向一个真正的锁（同步块），这个锁（同步块）会被复用。

## Mutex和lock有何不同？一般用哪一个作为锁使用更好？
Mutex是一个基于内核模式的互斥锁，支持锁的递归调用，而Lock是一个混合锁，一般建议使用Lock更好，因为lock的性能更好。

## 多线程和异步有什么关系和区别？
多线程是实现异步的主要方式之一，异步并不等同于多线程。实现异步的方式还有很多，比如利用硬件的特性、使用进程或线程等。在.NET中就有很多的异步编程支持，比如很多地方都有Begin***、End***的方法，就是一种异步编程支持，内部有些是利用多线程，有些是利用硬件的特性来实现的异步编程。

## 线程池的优点有哪些？又有哪些不足？
优点：减小线程创建和销毁的开销，可以复用线程；也从而减少了线程上下文切换的性能损失；在GC回收时，较少的线程更有利于GC的回收效率。

缺点：线程池无法对一个线程有更多的精确的控制，如了解其运行状态等；不能设置线程的优先级；加入到线程池的任务（方法）不能有返回值；对于需要长期运行的任务就不适合线程池。

## 并发和并行
并发：是指同一个cpu执行多个进程，进程之间交叉执行着指令

并行：指的是多cpu机器，分别单独的运行着不同的程序

# 其它

## 执行模型 CLR（Common Language Runtime）

公共语言运行库，负责资源管理（包括内存分配、程序及加载、异常处理、线程同步、垃圾回收等），并保证应用和底层操作系统的分离。

.NET 应用在称为“公共语言运行时 (CLR)”的运行时环境中运行托管代码。

## JIT 编译器和 IL
C# 等较高级的 .NET 语言编译为称为中间语言 (IL) 的硬件无关性指令集。 应用运行时，JIT 编译器将 IL 转换为处理器可理解的计算机代码。 JIT 编译发生在要运行代码的同一台计算机上。

由于 JIT 编译在应用程序的执行过程中发生，因此编译时间是运行时的一部分。 因此，JIT 编译器需要平衡优化代码所花费的时间与生成代码时可节约的时间。 但 JIT 编译器知道实际硬件，这样开发人员就无需为不同平台提供不同的实现。

.NET JIT 编译器可以执行分层编译，这意味着它可以在运行时重新编译各个方法。 通过此功能，它可以快速编译，同时仍然能够为常用方法生成高度优化的代码版本。

## AOT 编译器
大多数 .NET 工作负载的默认体验是 JIT 编译器，但 .NET 提供两种形式的预先 (AOT) 编译：

- 某些场景需要 100% AOT 编译。 例如 iOS。
- 在其他情况下，应用的大多数代码都是 AOT 编译的，但有些代码是 JIT 编译的。 某些代码模式不适用于 AOT（如泛型）。 这种形式的 AOT 编译的示例为准备运行发布选项。 这种形式的 AOT 具有 AOT 的优点并且没有 AOT 的缺点。

## 文件I/O

通过流的方式对文件进行读写操作

（1）FileStream

（2）StreamReader/StreamWriter

## 序列化与反序列化

序列化：将对象状态转换为可保持或传输的格式的过程。将对象实例的字段及类的名称转换成字节流，然后把字节流写入数据流。

反序列化：字节流转化为对象的过程。

这两个过程结合起来，可以轻松地存储和传输数据。

### Unity3D中序列化注意事项 Pure C# Class
> C#原生类型没法直接显示在编辑器中，必须添加个[System.Serializable]特性

## Hash表的原理是什么, 如何实现?

[C# 学习笔记：散列与哈希](https://blog.csdn.net/qq_38601621/article/details/100350691)

## 拓展方法
对于定义好的类进行拓展，比如String和Int类，但是拓展类和方法都应该是静态的。

## 反射Reflection

[C#面试题(二)(包含答案) ------ GC/反射泛型](https://qianxi.blog.csdn.net/article/details/81033250)

反射提供描述程序集、模块和类型的对象（Type 类型）。 可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型，然后调用其方法或访问器字段和属性。 如果代码中使用了特性，可以利用反射来访问它们。

反射可以读取程序集中代码的内容（dll和exe文件），反射中常用Type类和Assembly类获取命名空间、类名以及类的方法、属性、字段。

GetMethod()，GetProperties()，GetFiled()，据说反射还可以得到private方法。

## 反射的实现原理？
在运行时根据程序集及其中的类型得到元数据。下面是实现步骤：
1. 导入using System.Reflection;
2. Assembly.Load(“程序集”)加载程序集,返回类型是一个Assembly
3. 得到程序集中所有类的名称
foreach (Type type in assembly.GetTypes())
{
    string t = type.Name;
}
4. Type type = assembly.GetType(“程序集.类名”);获取当前类的类型
5. Activator.CreateInstance(type); 创建此类型实例
6. MethodInfo mInfo = type.GetMethod(“方法名”);获取当前方法
7. m.Info.Invoke(null,方法参数);

## 请简述ArrayList和List的主要区别？

ArrayList存在不安全类型（ArrayList会把所有插入其中的数据都当做Object来处理），装箱拆箱的操作（费时），List是泛型类，功能跟ArrayList相似，但不存在ArrayList所说的问题。

ArrayList存在不安全类型（ArrayList会把所有插入其中的数据都当做Object来处理）装箱拆箱的操作,List是泛型，可以指定特定的类型,避免过多的装箱拆箱操作,增加对内存的消耗;


## 浅克隆与深克隆（浅拷贝与深拷贝）

（1）浅克隆

在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制，如图：

![cs_shallow_copy](image/cs%20shallow%20clone.jpg)

通过实现ICloneable接口的Clone()方法，并调用MemberwiseClone()方法来实现浅克隆

（2）深克隆

在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制，如图：

![cs_deep_copy](image/cs%20deep%20clone.jpg)

在C#语言中，如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。

## C#中四种访问修饰符是哪些？各有什么区别？
- 属性修饰符：
Serializable：按值将对象封送到远程服务器。
STATread：是单线程套间的意思，是一种线程模型。
MATAThread：是多线程套间的意思，也是一种线程模型。
- 存取修饰符：
public：存取不受限制。
private：只有包含该成员的类可以存取。
internal：只有当前工程可以存取。
protected：只有包含该成员的类以及派生类可以存取。
- 类修饰符：
abstract：抽象类。指示一个类只能作为其它类的基类。
sealed：密封类。指示一个类不能被继承。理所当然，密封类不能同时又是抽象类，因为抽象总是希望被继承的。
- 成员修饰符：
abstract：指示该方法或属性没有实现。
sealed：密封方法。可以防止在派生类中对该方法的override（重载）。不是类的每个成员方法都可以作为密封方法密封方法，必须对基类的虚方法进行重载，提供具体的实现方法。所以，在方法的声明中，sealed修饰符总是和override修饰符同时使用。
delegate：委托。用来定义一个函数指针。C#中的事件驱动是基于delegate + event的。
const：指定该成员的值只读不允许修改。
event：声明一个事件。
extern：指示方法在外部实现。
override：重写。对由基类继承成员的新实现。
readonly：指示一个域只能在声明时以及相同类的内部被赋值。
static：指示一个成员属于类型本身，而不是属于特定的对象。即在定义后可不经实例化，就可使用。
virtual：指示一个方法或存取器的实现可以在继承类中被覆盖。
new：在派生类中隐藏指定的基类成员，从而实现重写的功能。 若要隐藏继承类的成员，请使用相同名称在派生类中声明该成员，并用 new 修饰符修饰它。