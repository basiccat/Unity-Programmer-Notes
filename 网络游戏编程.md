
- [网络架构](#网络架构)
  - [物理架构](#物理架构)
  - [逻辑架构](#逻辑架构)
  - [网游的四种形式](#网游的四种形式)
  - [MO架构和网络拓扑](#mo架构和网络拓扑)
    - [同步（帧同步）](#同步帧同步)
    - [同步/全网状](#同步全网状)
    - [同步/星型结构](#同步星型结构)
    - [同步方式的重大问题](#同步方式的重大问题)
    - [锁步回合制](#锁步回合制)
    - [异步](#异步)
  - [MMO架构和网络拓扑（状态同步）](#mmo架构和网络拓扑状态同步)
- [恶劣的网络环境](#恶劣的网络环境)
  - [影响因素](#影响因素)
  - [延迟处理](#延迟处理)
- [TCP和UDP](#tcp和udp)
  - [TCP与UDP区别总结：](#tcp与udp区别总结)
  - [TCP的缺点](#tcp的缺点)
  - [使用UDP在应用层实现可靠系统](#使用udp在应用层实现可靠系统)
  - [UDP的使用](#udp的使用)
- [同步](#同步)
  - [帧同步和状态同步的比较](#帧同步和状态同步的比较)
  - [帧同步](#帧同步)
    - [保证客户端独自计算的正确，即一致性](#保证客户端独自计算的正确即一致性)
    - [逻辑和显示的分离](#逻辑和显示的分离)
    - [帧同步网络协议](#帧同步网络协议)
    - [卡帧怎么处理](#卡帧怎么处理)
    - [帧同步定点数改造方案](#帧同步定点数改造方案)
    - [帧同步的碰撞检测和碰撞效果](#帧同步的碰撞检测和碰撞效果)
    - [帧同步遍历问题](#帧同步遍历问题)
    - [帧同步出现不同步，怎么查的](#帧同步出现不同步怎么查的)
    - [对于网络中角色操作的同步，场景中NPC的同步的看法。](#对于网络中角色操作的同步场景中npc的同步的看法)
- [通信](#通信)
  - [Unity如何对接网络游戏服务器？](#unity如何对接网络游戏服务器)
  - [客户端怎么判断掉线](#客户端怎么判断掉线)
  - [断线重连怎么做的](#断线重连怎么做的)
  - [Socket粘包](#socket粘包)
    - [什么情况下需要考虑粘包？](#什么情况下需要考虑粘包)
    - [解决粘包](#解决粘包)
  - [Socket的封包、拆包](#socket的封包拆包)
  - [Socket 客户端 队列](#socket-客户端-队列)
- [其它](#其它)
  - [通信中间件libevent](#通信中间件libevent)




# 网络架构

## 物理架构

指标 | C/S | P2P
------------ | ------------ | -------------
延迟| 大 | 小
服务器设备成本| 大 | 小
非法行为| 困难 | 容易
网络拓扑|星型结构| 全网状 星型结构

## 逻辑架构

指标 | MO | MMO
------------ | ------------ | -------------
玩家数| 20左右 | 超多
延迟| 低 | 较高
运行时间|短|超长
网络拓扑|同步 异步| 浏览器方式

MO/MMO混合：开副本用MO

## 网游的四种形式

结构 | MO | MMO
------------ | ------------ | -------------
C/S| 休闲游戏 | MMORPG 大战场
P2P| 格斗类 竞速 射击 RTS | 无

## MO架构和网络拓扑

### 同步（帧同步）
***
客户端之间只同步输入指令。只有在获得了全体玩家的信息之后，游戏才能继续下去的行为。

### 同步/全网状
参与游戏的终端都拥有主数据，互相传输控制设备输入信息。在获得全部终端的输入数据前游戏会等待。

必要条件：
- 初始状态完全相同
- 所有输入信息数据包完完整整地到达其它终端
- 游戏过程数据完全一致（伪随机数）

做法：
- 不使用浮点数，改用整数
- 伪随机数种子保持一致
- 保持相同的初始状态
- 逻辑代码执行顺序相同（排序遍历顺序相同）
- 使用预测和模拟算法掩盖卡顿
- 使用UDP冗余的方式对抗较弱的网络环境

缺点：
- 人数增加后数据完整性难保证
- 最慢的终端会拖累整体
- 不容易中途加入游戏

### 同步/星型结构
所有参与游戏的终端把输入信息传给服务器，服务器把那些改变了的状态返回给所有客户端。服务器返回信息前全部终端等待。最大的优点是随玩家数量增加，传输压力不会爆发性增长，所以数据不一致的可能性更低。

缺点：
- 响应慢
- 如果主机离线游戏就会中断
- 代码编写比起全网状更加复杂
- 主机压力甚大，不公平

### 同步方式的重大问题
不容易中途加入游戏，不然所有其他玩家必须长时间等待新玩家完成全部模拟。

### 锁步回合制
在游戏中只传输“轮”数据包，这些数据包含某一轮中每个对等体发出的一系列命令和其它关键数据。

### 异步

异步方式也有全网状和星型结构这两种实现方式。

各个终端上的游戏状态是不同的，游戏在一致性上作出妥协，应对更不稳定的传输线路和延迟更大的线路。也可以支持更多的在线人数。但是编程方面更加复杂。

对游戏内容的详细需求分析是必不可少的。

可能出现的问题：结果不一致。
具体体现在：
- 自己和对手：对战游戏和玩家之间往来数据的抽象程度
- 自己和环境：互斥控制，静态环境和动态环境
- 对手和环境：不重要，减少信息量

## MMO架构和网络拓扑（状态同步）

浏览器方式：管理数据的只有服务器，终端只是将当前游戏状态呈现给玩家。

纯粹的C/S模式。

常规MMO类型的游戏只能使用状态同步。

解决游戏服务器的瓶颈：
- 空间分割法
- 实例法（多频道）
- 平行世界（分区）
- 综合

# 恶劣的网络环境

## 影响因素
延迟：非网络延迟，网络延迟

抖动：抖动会影响RTT（往返时间）抑制算法，最糟的是导致数据包乱序到达。

丢包：不可避免。

## 延迟处理
沉默的终端：不预测不模拟

客户端插值：仍比较保守，仅在服务器真正模拟的两个状态之间的插值。

客户端预测：客户端通过略旧的状态推测近似的最新状态。

航位推测法：基于实体继续做当前正在做的事情这一假设，进行实体行为预测的过程。不保守的算法，被称为“乐观算法”。

当模拟不一致时，客户端需要及时弥补：
- 立即更新至最新状态（闪现）
- 插值
- 二阶状态调整

服务器端回退：当瞄准开火时，服务器回退到玩家感受到的那个状态。

# TCP和UDP

## TCP与UDP区别总结：

TCP|UDP
---|---
TCP面向连接（如打电话要先拨号建立连接）| UDP是无连接的，即发送数据之前不需要建立连接
TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达 | UDP尽最大努力交付，即不保   证可靠交付
TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流|UDP是面向报文的
有拥塞控制|UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
每一条TCP连接只能是点到点的|UDP支持一对一，一对多，多对一和多对多的交互通信
TCP首部开销20字节|UDP的首部开销小，只有8个字节
TCP的逻辑通信信道是全双工的可靠信道|UDP则是不可靠信道

## TCP的缺点
TCP要求发送的东西必须被可靠发送且按序处理，但是会造成问题，
1. 低优先级数据丢失干扰高优先级数据的接收。
2. 两个单独的可靠有序数据流互相干扰。
3. 过失状态重传。
4. 拥塞控制可能不如预期。
5. TCP为管理连接和跟踪所有可能重传的数据分配了很多资源。

## 使用UDP在应用层实现可靠系统
KCP - A Fast and Reliable ARQ Protocol

KCP是一个快速可靠协议，能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责**底层协议（如UDP）**的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。

## UDP的使用
- 发送那些与可靠性相比到达速度更重要的数据
- 为了实现NAT遍历，解决NAT网络建立通信路径的技术

# 同步

[帧同步联机战斗（预测，快照，回滚）](https://zhuanlan.zhihu.com/p/38468615)

[Unity帧同步解决方案（一）](https://zhuanlan.zhihu.com/p/66582899)

[Unity帧同步解决方案（二）](https://zhuanlan.zhihu.com/p/67273047)

[网络同步解决方案](https://www.cnblogs.com/gangtie/p/14406788.html)

[帧同步的相关问题](https://www.cnblogs.com/gangtie/p/12629509.html)


## 帧同步和状态同步的比较

状态同步:将其他玩家的状态行为同步的方式，一般情况下AI逻辑，技能逻辑，战斗计算都由服务器运算，将运算的结果同步给客户端，客户端只需要接受服务器传过来的状态变化，然后更新自己本地的动作状态、Buff状态，位置等就可以了，但是为了给玩家好的体验，减少同步的数据量，客户端也会做很多的本地运算，减少服务器同步的频率以及数据量。

帧同步，状态同步，分别怎么应对恶劣网络环境？

帧同步对网络要求比较高，帧同步是锁帧的，如果有网络的抖动，一段时间调用次数不稳定，网络命令的延迟就会挤压，引起卡顿。

状态同步对于网络的带宽和抖动包有更强的适应能力，即便出现了200、300的输入延迟再恢复正常，玩家其实也感受不到不太舒服的地方。

## 帧同步

帧同步的基础，是不同的客户端，基于相同的操作指令顺序，各自执行逻辑，能得到相同的效果。就如大家所知道的，在unity下，不同的调用顺序，时序，浮点数计算的偏差，容器的排序不确定性，coroutine内写逻辑带来的不确定性，物理浮点数，随机数值带来的不确定性等等。

### 保证客户端独自计算的正确，即一致性

有些比较好解决，比如随机数值，只需要做随机种子即可。

有些注意代码规范，比如在帧同步的战斗中，逻辑部分不使用Coroutine，不依赖类似Dictionary等不确定顺序的容器的循环等。

要通过一个统一的逻辑tick入口，来更新整个战斗逻辑，而不是每个逻辑自己去Update。保证每次tick都从上到下，每次执行的顺序一致。

浮点数计算无法保证一致性，我们需要转换为定点数

### 逻辑和显示的分离

### 帧同步网络协议

首先，是网络协议的选择。TCP和UDP的选择，我就不多说了，帧同步肯定要基于UDP才能保证更低的延迟。在UDP的选择上，我看网上有些文章，容易导入一个误区，即，我们是要用可靠传输的UDP，还是冗余信息的UDP。

基于可靠传输的UDP，是指在UDP上加一层封装，自己去实现丢包处理，消息序列，重传等类似TCP的消息处理方式，保证上层逻辑在处理数据包的时候，不需要考虑包的顺序，丢包等。类似的实现有Enet，KCP等。

冗余信息的UDP，是指需要上层逻辑自己处理丢包，乱序，重传等问题，底层直接用原始的UDP，或者用类似Enet的Unsequenced模式。常见的处理方式，就是两端的消息里面，带有确认帧信息，比如客户端（C）通知服务器（S）第100帧的数据，S收到后通知C，已收到C的第100帧，如果C一直没收到S的通知（丢包，乱序等原因），就会继续发送第100帧的数据给S，直到收到S的确认信息。

### 卡帧怎么处理

什么是追帧：当前玩家播放到帧比服务器的帧落后时，服务器下发多个帧，玩家便要开始快进到服务器当前帧
为什么要追帧：如果网络波动，服务器会有最晚的接受帧时间，
做法：超过则下次发送多个帧，然后快进播放（多次DoAction），快进期间，不播放特效音效等不影响运行结果的逻辑

### 帧同步定点数改造方案

因此大部分项目都会自己去实现定点数的重新封装，把整数和小数拆开来都用32位整数表示封装在某个类中，再写一些关于定点数之间以及定点数与其他类型数字的数学计算库。

最最最快速简单，性价比最高的的方式，其实是将所有浮点数改为整数并乘以1000或者10000表达完整的数，以整数的方式来计算结果就不会有问题。

最佳的解决办法，是使用实现更加精确和严谨，并经过验证的定点数数学库，在c#上，有一个定点数的实现，Photon网络的早期版本，Truesync有一个很不错的定点数实现。

### 帧同步的碰撞检测和碰撞效果


### 帧同步遍历问题

不确定顺序的容器的遍历要严令禁止，lua表的遍历，for pairs是必须要禁止的，可以使用for ipairs。C++的Map等，总之在使用容器的遍历时，一定要查阅是否是确定顺序的。

接管物理的update，Physics.SyncTransforms  Physic.Simulate(time)

顺序一致：角色的创建顺序、各种玩法的创建顺序、OnTriggerXX的顺序

帧同步驱动各系统update代码，不使用Mono的update和Invoke等、

### 帧同步出现不同步，怎么查的

检验和(checksum) 循环冗余检测(CRC)

在整体框架搭建好后，一定要赶紧完成这几个比较重要的工具。不同步信息查看工具，录像播放工具，自动战斗工具。

### 对于网络中角色操作的同步，场景中NPC的同步的看法。

角色：可以考虑帧同步的方案，大部分游戏逻辑都在客户端实现，服务器只负责广播和验证操作

npc：可以考虑状态同步，只同步npc的状态行为，ai逻辑，技能逻辑，战斗计算都由服务器计算，然后将运算结果同步给客户端，客户端只需要接受服务器传过来的状态变化然后更新本地的动作状态，buff，位置等待；

# 通信

## Unity如何对接网络游戏服务器？

[unity游戏框架学习-实现c#的网络框架](https://www.cnblogs.com/wang-jin-fu/p/11121654.html)

Socket负责和游服的通信，包括网络的连接、消息的接收、心跳包的发送、断线重连的监听和处理

那一个完整的网络模块包括几方面呢？（仅讨论客户端）

1.建立和服务端的socket连接，实现客户端-服务端两端的接收和发送功能。

2.消息协议的选择，网络消息的解析可以是json、xml、protobuf

3.消息缓存

4.消息的监听、分发、移除

5.客户端身份验证，由客户端、服务端生成密钥进行验证。

6.心跳包的实现，主要是检测客户端的连接情况，避免浪费服务端资源

## 客户端怎么判断掉线
[Unity3D网络-心跳包](https://www.jianshu.com/p/caab9e44466e?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)

TCP长连接建立连接后，理想状态下是不会断开的，但是由于网络问题，可能导致一方断开后，另一方仍然在发送数据，或者有些客户端长时间不发送消息，服务器还维持这他的客户端不必要的引用，增加了服务器的负荷。因此我们引入了心跳机制。

心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。

总的来说，心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。

怎么发送心跳？

1：轮询机制：概括来说是服务端定时主动的与客户端通信，询问当前的某种状态，客户端返回状态信息，客户端没有返回，则认为客户端已经宕机，然后服务端把这个客户端的宕机状态保存下来，如果客户端正常，那么保存正常状态。如果客户端宕机或者返回的是定义的失效状态那么当前的客户端状态是能够及时的监控到的，如果客户端宕机之后重启了那么当服务端定时来轮询的时候，还是可以正常的获取返回信息，把其状态重新更新。

2：心跳机制：最终得到的结果是与轮询一样的但是实现的方式有差别，心跳不是服务端主动去发信息检测客户端状态，而是在服务端保存下来所有客户端的状态信息，然后等待客户端定时来访问服务端，更新自己的当前状态，如果客户端超过指定的时间没有来更新状态，则认为客户端已经宕机。

心跳比起轮询有两个优势：1.避免服务端的压力  2.灵活好控制

## 断线重连怎么做的
[谈谈Unity游戏TCP连接和网络重连](https://www.jianshu.com/p/d610d352e1f0)

[TcpClient 类](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.tcpclient?view=net-6.0)

断线重连第一步监听TcpClient使用的过程中，对于异常发生之后触发重连逻辑。但在移动端比较重要的一点还要做好从后台切回前台过程中及时检查网络连接状态及时重连。

## Socket粘包

什么是粘包？ 顾名思义，其实就是多个独立的数据包连到一块儿。

### 什么情况下需要考虑粘包？ 

如果利用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题。

如果发送的数据无结构，比如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包。

如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构：  1)”good good study”  2)”day day up”，那这样的话，如果发送方连续发送这个两个包出去，接收方一次接收可能会是”good good studyday day up” ，这样接收方就傻了，因为协议没有规定这么奇怪的字符串，所以要把它分包处理，至于怎么分也需要双方组织一个比较好的包结构，所以一般可能会在头加一个数据长度之类的包，以确保接收。

所以说：Tcp连续发送消息的时候，会出现消息一起发送过来的问题，这时候需要考虑粘包的问题。

粘包出现的原因 (在流传输中，UDP不会出现粘包，因为它有消息边界。)
- 发送端需要等缓冲区满才发送出去，造成粘包 (发送端出现粘包)
- 接收端没有及时接收缓冲区包数据，造成一次性接收多个包，出现粘包 (接收端出现粘包)

### 解决粘包

1、缓冲区过大造成了粘包，所以在发送/接收消息时先将消息的长度作为消息的一部分发出去，这样接收方就可以根据接收到的消息长度来动态定义缓冲区的大小。（这种方法就是所谓的自定义协议，这种方法是最常用的）

2、对发送的数据进行处理，每条消息的首尾加上特殊字符，然后再把要发送的所有消息放入一个字符串中，最后将这个字符串发送出去，接收方接收到这个字符串之后，再通过特殊标记操作字符串，把每条消息截出来。(这种方法只适合数据量较小的情况)

注：要记住这一点：TCP对上层来说是一个流协议，所谓流,就是没有界限的一串数据.大家可以想想河里的流水,是连成一片的,其间是没有分界线的，也就是没有包的概念。所以我们必须自己定义包长或者分隔符来区分每一条消息。

## Socket的封包、拆包

1、为什么基于TCP的通信程序需要封包、拆包? 
答：TCP是流协议，所谓流，就是没有界限的一串数据。但是程序中却有多种不同的数据包，那就很可能会出现如上所说的粘包问题，所以就需要在发送端封包，在接收端拆包。

2、那么如何封包、拆包？ 
答：封包就是给一段数据加上包头或者包尾。比如说我们上面为解决粘包所使用的两种方法，其实就是封包与拆包的具体实现。

## Socket 客户端 队列
项目中采用了socket通信，通过TCP发送数据给服务器端，因为项目需要，要同时开启大量的线程去发送不同的数据给服务器端，然后服务器端返回不同的数据。由于操作频繁，经常会阻塞，或没有接收到服务器端返回的数据。 

因此考虑到使用一个队列，将同一ip下的数据存入一个队列中，通过队列协调发送；当第一条数据发送出去没有收到服务器端返回的数据时，让第二条数据插入队列中排队，当第三条数据也发送出来后，继续排队，以此类推；如果当第四条数据发出来的时候，存入队列中，第一条数据收服务器端返回数据后，队列中的第二条第三条数据就扔掉，直接发送第四条数据


# 其它

## 通信中间件libevent
单线程+事件驱动+非阻塞调用；

libevent最大的特点是不创建线程，为每一个想要事先通知的事件注册回调函数，当事件发生时只进行一次函数调用。
